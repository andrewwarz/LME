import os
import sys
import random
import string
import subprocess
import shutil
import os
import pathlib
import logging
import argparse
import re

#use orc's minimega version (hash of git commit for mini is in the file)
#generated by minimega on the server:
#/opt/minimega/bin/pyapigen /opt/minimega/bin/minimega
from orc.minimega import connect

       

def install_windows(disk, iso, vm_name, filepath='/tmp/minimega/files', namespace="minimega"):
    #setup mm
    mm = connect()

    ## Start VM Template
    mm.vm_flush()
    mm.clear_vm_config()
    mm.vm_config_disks(disk)
    mm.vm_config_cdrom(iso)
    mm.vm_config_vcpus('4')
    mm.vm_config_memory('4096')
    mm.vm_config_snapshot('false')
    mm.vm_launch_kvm(vm_name)
    mm.vm_start(vm_name)

    return vm_name


def UnmountWimFile(wimmount_dir):
    try:
        unmount_command = ['sudo', 'wimunmount', wimmount_dir, "--commit"]
        subprocess.run(unmount_command, check=True)
        print(f".wim file unmounted from '{wimmount_dir}'")
    except Exception as e:
        print(f"Error: {e}")
        return False
    return True

def RepackageModifiedIso(tmp_path, extract_dir):
    os.system(f'genisoimage -bboot/etfsboot.com -no-emul-boot -boot-load-seg 1984 -boot-load-size 8 -iso-level 2 -J -l -D -N -joliet-long -allow-limited-size -relaxed-filenames -o {tmp_path}/modified_windows.iso {extract_dir}')
    return f"{tmp_path}/modified_windows.iso"
        

def CopyAnswerFileIntoIso(answer_file_path, extract_dir):
    os.system(f"cp {answer_file_path} {extract_dir}")


def MoveModifiedWimIntoIso(tmp_path, original_wim_file_path):
    os.system(f"sudo mv {tmp_path}/install.wim {original_wim_file_path}")
    

def CopyVirtioIntoMountedWim(msi_file_path, wimmount_dir):
    cmd = f"cp {msi_file_path} {wimmount_dir}"
    os.system(cmd)
    

def mount_wim(tmp_path, wimmount_dir):
    """
    get image partition and mount info
    """

    wim_file_path = f"{tmp_path}/install.wim"
    # Getting the index number of the image associated with "Windows ## Pro"
    command = ['wiminfo', wim_file_path]
    result = subprocess.run(command, capture_output=True, text=True, check=True)

    pattern = r"Index:\s*(\d+)\s*\nName:\s*(.+)"
    match = re.search(pattern, result.stdout)

    if match:
        index = match.group(1)
        name = match.group(2)
        result = [index, name]
        print(result)

    index_match = re.search(pattern_index, output_lines)
    name_match = re.search(pattern_name, output_lines)

    if index_match and name_match:
        index = int(index_match.group(1))
        name = name_match.group(1).strip()
        index_dict[name] = index
    print(index_dict)

    image_number = None
    for key, value in index_dict.items():
        #TODO: may need to modify for other isos
        image_number =  value

    if image_number == None:
        logging.error("ERROR: Could not find the image number")
        logging.error("ERROR: FAILING")
        exit(-1)

    wimfile_path = wim_file_path
    image_index = image_number
    try:
        os.makedirs(wimmount_dir, exist_ok=True)
        mount_command = ['sudo', 'wimmountrw', wimfile_path, str(image_index), wimmount_dir]
        subprocess.run(mount_command, check=True)
        logging.info(f".wim file mounted at '{wimmount_dir}'")
    except Exception as e:
        logging.error(f"Error: {e}")
        exit(-1)
    return 1


def extract_iso(tmp_path, iso_filepath, extract_dir):
    # Extracting Windows ISO
    iso_mount_dir = f"{tmp_path}/iso"
    os.makedirs(extract_dir, exist_ok=True)
    os.makedirs(iso_mount_dir, exist_ok=True)
    os.system(f"sudo mount -o loop {iso_filepath} {iso_mount_dir}")
    os.system(f"cp -r {iso_mount_dir}/* {extract_dir}")
    os.system(f"sudo umount {iso_mount_dir}")
    logging.info("\tFinished iso mount")

    # Extracting the ISO file and getting the install file"
    for root, dirs, files in os.walk(extract_dir):
        for filename in files:
            if filename.lower() in ['install.esd', 'install.wim']:
                found_path = os.path.join(root, filename)
                logging.info(f"Found Path:\t{found_path}")

    if found_path == None:
        logging.error("The install file was not found.")
        exit(-1)
    
    # Copying Wim file to current directory
    shutil.copy(found_path, tmp_path)
    return found_path 


def mod_iso(tmp_path, iso_filepath, msi_file_path, answer_file_path):
    #extracted iso file
    extract_dir = f"{tmp_path}/extracted/"
    #mounted WIM file
    wimmount_dir = f"{tmp_path}/mounted/"

    original_wimfile_path = extract_iso(tmp_path, iso_filepath, extract_dir)
    mount_wim(tmp_path, wimmount_dir)
    exit(-1)
    CopyVirtioIntoMountedWim(msi_file_path, wimmount_dir)
    UnmountWimFile(wimmount_dir)
    MoveModifiedWimIntoIso(tmp_path, original_wimfile_path)
    CopyAnswerFileIntoIso(answer_file_path, extract_dir)
    modified_windows_iso_path = RepackageModifiedIso(tmp_path, extract_dir)
    return modified_windows_iso_path


def create_qcow_image(size, path):
    """
    Create a blank qcow2 image.
    
    Args:
        size (str): Size of the image (e.g., '20G' for 20GB).
        path (str): Path to save the qcow2 file.
    """
    if os.path.exists(path):
        raise FileExistsError(f"QCOW2 file {path} already exists.")
    cmd = ['qemu-img', 'create', '-f', 'qcow2', path, size]
    subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

if __name__ == "__main__": 
    parser = argparse.ArgumentParser(description="Create an Windows qcow2 image with SSH and DHCP.")
    parser.add_argument("-t", "--tld", required=True, help="top level directory for everything")
    parser.add_argument("-k", "--ssh-key-path", required=True, help="Path to SSH public key file")
    parser.add_argument("-o", "--output-file", default="windows_gold.qcow2", help="Filename for  output qcow2 image, stored at $TLD/files")
    parser.add_argument( "--win-iso", default="win11.iso", help="win iso filename, assumes stored at $TLD/files")
    parser.add_argument("--virt-iso", default="virtio-win-0.1.240.iso", help="virtio driver iso filename, assumes stored at $TLD/files")
    args = parser.parse_args()

    if not (os.geteuid() == 0):
        logging.error("Must be running with root privileges")
        exit(-1)


    TLD = args.tld

    # Define paths
    files_path = os.path.join(TLD, 'files/')
    qcow_path = os.path.join(files_path, args.output_file)
    windows_iso = os.path.join(files_path + args.win_iso)
    virt_iso = os.path.join(files_path + args.virt_iso)

    #use the deps/ in the library
    current_dir = pathlib.Path(__file__).parent.parent
    unattended_template = os.path.join(current_dir, 'deps/Autounattend.xml')
    script_path = os.path.join(current_dir, 'deps/enable_ssh.ps1')

    # Create the qcow image
    if os.path.exists(qcow_path):
        base_name, extension = os.path.splitext(qcow_path)
        i = 1
        while os.path.exists(qcow_path):
            qcow_path = f"{base_name}_{i}{extension}"
            i += 1
        logging.info(f"FILE EXISTS using: {qcow_path}")
        create_qcow_image('100G', qcow_path)

    #modify the iso
    tmp_path = f'temp_{"".join(random.choices(string.ascii_lowercase, k=10))}'
    logging.info(f"using {tmp_path}")
    modded_iso = mod_iso(tmp_path, windows_iso, virt_iso, unattended_template)

    # Install Windows
    install_windows(qcow_path, modded_iso, "win_template")
